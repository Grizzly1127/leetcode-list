# 打家劫舍

来源：力扣（LeetCode）  
链接：<https://leetcode-cn.com/problems/house-robber/>

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

示例1：

``` c++
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例2：

``` c++
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

</br>

---

## 思路

### 动态规划 + 滚动数组

根据题目可知，前提条件是不能在相邻房屋盗窃。  
考虑最简单的情况，当房间数为 1 时，盗窃结果为nums[0]，当房间数为 2 时，盗窃结果为`max(nums[0], nums[1])`。  
当房间大于2时，当前位置`n`房屋可盗窃的最大值，有两种情况：  

* 要么就是`n-1`可盗窃房屋的最大值
* 要么就是`n-1`可盗窃房屋的最大值加上当前`n`房屋的值。

所以当前位置`n`的盗窃的最大值应该是取二者之间的最大值。

以上可得到动态规划方程：`dp[n] = max(dp[n - 1], dp[n - 2] + nums[n])`：
例如示例1中，0号房间可盗窃的最大值为`1`，1号房间可盗窃的最大值为`2`，2号房间可盗窃的最大值为`dp[2] = max(dp[1], dp[0] + 3) = max(2, 4) = 4`，3号房间可盗窃的最大值为`dp[3] = max(dp[2], dp[1] + 1) = max(4, 3) = 4`，所以最高盗窃金额为`4`。  

优化：  
动态规划需要用到数组来记录每一步的结果，其实该方程只关心n的前两个房间的最高金额，因此可以用到滚动数组，在每个时刻只需要存储前两个房间的最高总金额。

算法时间复杂度：  
O(n)

</br>

## 解题

``` c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        } else if (nums.size() == 1) {
            return nums[0];
        }

        int first = nums[0], second = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); ++i) {
            int temp = second;
            second = max(second, first + nums[i]);
            first = temp;
        }
        return second;
    }
};
```
